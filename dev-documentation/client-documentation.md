# Client Documentation

### Introduction

This documentation includes everything you need to know in order to implement your own client for the R-Type server.

With this client, you should be able to connect to a game being run on the server alongside players currently using the default client implementation that we provide.

### Entity Component System

At the core of the R-Type server architecture is the Entity Component System (or ECS). This entity component system will only be updated by the server which will then communicate the updates to the client though our UDP game protocol.

#### Serialization

In order for the client to communicate the changes made to the ECS to the client, it is important that the client defines serialization and deserialization methods for each component.

The servers component serialization follow the following format :

`ComponentID,component arg1,component arg2...`

ComponentID is the unique component ID that has to be generated by the client in the same order as the server. This will be explained later on in this document.

After the ComponentID, each arg will be serialized separated by commas. These arguments are serialized in the same order as they appear in the component struct definition. It is **crucial** that the client deserialize the components attributes in the same order as they appear in the component definitions we provide further along in this document.

#### Components

The following are the server side definitions of the components.

```cpp
struct Armor {
        int armor = 0;
};

struct Health {
        int health = 0;
        int maxHealth = 0;
        bool visible = false;
};

struct Position {
        float x = 0;
        float y = 0;
};

struct Animation {
        AnimationID animationID;
        unsigned long layer = 1;
        double rotation = 0;
        double scale = 3;
        int index = 0;
        std::chrono::time_point<std::chrono::system_clock> timer;
};

struct Velocity {
        float x = 0;
        float y = 0;
        EntityID follow = -1;
};

struct Player {
        int score;
        int uniqueID;
};

struct Damage {
        int damage = 0;
};

struct Armament {
        Armament::Type type;
        double interval = 0.1;
        long long ammo = -1;
        std::chrono::time_point<std::chrono::system_clock> timer;
};

struct Hitbox {
        Point topLeft;
        Point topRight;
        Point botLeft;
        Point botRight;
};

enum Team {
    Ally,
    Enemy,
};

struct ImmunityFrame {
    double duration = 0;
    std::chrono::time_point<std::chrono::system_clock> timer;
};

struct SoundCreation {
    SFXID ID;
};

struct SoundDestruction {
    SFXID ID;
};

struct SoundDamage {
    SFXID ID;
};

//SFXID is an enum that the client can associate sound effects to
```

#### Systems

In order for the client to display the information received by the server, only one system needs to be implemented. This system is the animation drawing system that should allow it to draw static and animated sprites.

All sprite sheets required by the game to run will be provided in a directory named 'ressources'.

#### Player controls

To communicate the direction a player wants to move the following enum is used:

enum Move { UP = 1, DOWN = -1, LEFT = 3, RIGHT = -3 }

The integer coresponding to the desired direction can be calculated by adding the integers in the enum that have an influence on the final direction.

e.g.: Down right = DOWN + RIGHT = -1 - 3 = -4
